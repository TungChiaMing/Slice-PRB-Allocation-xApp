==================================================================================

       Copyright (c) 2020 AT&T Intellectual Property.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

==================================================================================

Traffic Steering
================

This repository contains the source for the RIC traffic steering application.

This xApp can be onboarded through the xApp Onboarder.  The xapp descriptor
is under the xapp-descriptor/ directory.

Then the xapp can be deployed through the App Manager.

In order for Traffic Steering xApp to carry out the Traffic Steering Use Case,
the following needs to be done:
* QP xApp needs to be onboarded and deployed (see xapp descriptor in that repo)
* QP Driver xApp needs to be onboarded and deployed (see xapp descriptor in that repo)
* SDL must contain network data which required by the QP Driver xApp

Mock network data
=================

KPIMON xApp is in charge of collecting RAN metrics and write to SDL.

However, the Traffic Steering Use Case can be run with mock data.  Everything needed to write this
mock data is included in this repo.  Directions are as follows:

cd test/populatedb

chmod a+x populate_db.sh

./populate_db.sh

This script will build a docker image locally and also install a helm chart in the kubernetes cluster to run the image.

The code that is run will write the necessary data to SDL

Mock applications (Release D)
=============================

There are sample applications in the test/app/ directory that demonstrate a dummy message exchange
among AD, QP Driver, QP, and TS xApps. Currently, there is no Dockerfile to run those mock applications,
but they can be built according to the following:

1. Build the TS xApp
2. $cd test/app/
3. $cmake -S . -B build
4. $cd build/
5. $make

Run xApps in the following order:
1. TS xApp
2. qp_xapp
3. ad_xapp

There is an additional application that mocks a Rest server to demonstrate all control messages
issued by the TS xApp. It is implemented in Python and echoes all messages it receives. This
application is located at the test/app directory.



Modification is based on osc ric-app-ts branch e-release  https://github.com/o-ran-sc/ric-app-ts

## New functions designed by K. D.

- There're three new functions added in ts_xapp.cpp
    - random slice PRB
    - slice allocation
    - manipulate data
        - write influxdb
        - read dummy data generated by RIC Test
        - write file with the output
        ã€€
### Random slice PRB

- why 
    - RIC Test does not support Slice info, Therefore, it is necessary to have the function of simulating slice 

- Rule must be follow : 
    - 1. only three slices can be used , and they are `embb` ,  `mmtc` ,  `urllc` (only lowercase)
    - 2. before read the dummy data, we need to assign UE which kind of slices will use  as string `slice1_slice2_slice3`
        - e.g. : `embb_mmtc` or `urllc_mmtc_embb` or `urllc`
 
- introduce the function about it
    - function `slice_parser` will handle b. and parse it into how many slice the UE use and which kind of slice the UE use


    - function `uniform_random_slice_prb` is responsible for random the slice PRB to the slice the UE is using
        - note: the sum of all the slice PRB will be total PRB

###  Manipulate data - read dummy data generated by RIC Test


- why
    - since I just use the data downloaded from the RIC Test and save it as the file

- Rule must be follow
    - 1. The dummy data file needs to be a csv file , location is `/influxdb-dummy-data`
    - 2. first row shall be the type of metrics , e.g., `ue-id` or `prb_usage`


- example
<div>
<img src="https://github.com/TungChiaMing/Slice-PRB-Allocation-xApp/blob/e-release/screenshots/example_csv.png" width="100%"/>
</div>


- how to use
    1. Load your dummy UeMetrics  
        - 1.1 in the function `get_dummy_data`   ueFile.open(type_your_Uemetrics_file_name_here);

        e.g.,
        ```cpp
        get_dummy_data(){


            ueFile.open("valid.csv");
        }

        ```
        - 1.2 in the function `get_dummy_data`   int File_length = your_Uemetrics_file_total_row;


        e.g.,
        ```cpp
        get_dummy_data(){


            ueFile.open("valid.csv");

            int File_length = 21;
        }

        ```


    2. Load your dummy CellMetrics  
        - 1.1 in the function `get_dummy_data`   cellFile.open(type_your_Cellmetrics_file_name_here);

        e.g.,
        ```cpp
        get_dummy_data(){


            ueFile.open("MeasReport_cell.csv");
        }

        ```
        - 1.2 in the function `get_dummy_data`  int File_length = your_Cellmetrics_file_total_row;
        
        
        e.g.,
        ```cpp
        get_dummy_data(){


            ueFile.open("MeasReport_cell.csv");

            int File_length = 41;
        }

        ```

    3. Get the data
        - 1. After function `get_dummy_data()` executed , data will be store in 
            `vector< unordered_map<string, string> > cell_group` and `vector< unordered_map<string, string> > ue_group`
        - 2. Access it by using iterater and the type in the metrics !
 
###  Manipulate data - write file with the output
- why   
    - output the outcome of computation to get the utilization of base station

 
- how to do


```cpp
// declear the name of the output file
string line;
string outcome = "outcome.csv";

                 
// open the file and check whether state of stream is good
ifstream fin(outcome.c_str(), std::ios::in);
if(fin.good()){
    stringstream buffer;

    
    // read all the column in the file
    while (getline(fin, line)) buffer<<line+",\n";



    // append the outcome to the buffer
    ofstream fout(outcome.c_str(), std::ios::out);
    buffer << Tot_BS_utilization/it_cnt << "," << (double)(end - begin) / CLOCKS_PER_SEC << endl ;
    fout << buffer.rdbuf();
}  
```

###  Manipulate data - write influxdb


Modification is based on offa InfluxDB C++ client library branch master https://github.com/offa/influxdb-cxx


- why   
    - write influxdb so that we can see the visualized data

- note
    - I just build the images with influxdb_cxx , so you can use functions in influxdb directly


- how to do


```cpp
/* using the source code from offa InfluxDB C++ client library branch master */
// assign a variable to get the return address of influxdb

auto db_influx = influxdb::InfluxDBFactory::Get(influxdb_url);

```

```cpp
/* using the source code from offa InfluxDB C++ client library branch master */
// write influxdb with a point

db_influx->write(influxdb::Point{"slice_usage"}
.addField("ueid", UE_Group[i].Name  )    

);
 
```



###  slice allocation

- why
    - do slice PRB allocation


- Rule must be follow
    - 1. Types in UE Metrics shall be the follow:
        -  `nrCellIdentity` 
        - `prb_usage`
        - `ue-id`
        - `nbCellIdentity_0` 
        - `nbCellIdentity_1` 
        - `nbCellIdentity_2`
        - `nbCellIdentity_3` 
        - `nbCellIdentity_4`  
        - `Slices`
    - 2. Types in Cell Metrics shall be the follow:
        - `nrCellIdentity`
        - `availPrbDl`
        - `usedPrbDl`


- introduce the function , `slice_allocation`    

    ```cpp

    /* 
    
    It only accept the three argument below
    1. std::vector<UE> ue_list, 
    2. std::vector<Cell> cell_list, 
    3. std::vector<std::string> slice_list

    struct UE and struct Cell has already defined in the ts_xapp.cpp

    For now, slice list only accept three slice , respectively , embb , mmtc , urllc

    declear the vector variable of UE and Cell , and then read your dummy data to use it!
    
    */
    
    void slice_allocation(std::vector<UE> &ue_list, std::vector<Cell> &cell_list, std::vector<std::string> &slice_list){

        // do slice allocation
    }
    ```